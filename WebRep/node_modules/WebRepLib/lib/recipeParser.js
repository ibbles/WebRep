const {log} = require("./log");

function parseRecipeFromString(recipeText) {
    var recipeBuilder = createRecipeBuilder();
    const lines = recipeText.split('\n');
    lines.forEach(function (line) {
        line = line.trim();
        recipeBuilder.parseLine(line);
    });

    const recipe = recipeBuilder.recipeGetter();
    return recipe;
}


/**
 * Constructor function that create a recipe builder object.
 *
 * On the recipe builder, call parseLine for each line in the recipe and after
 * all lines has been parsed call getRecipe to get the recipe.
 */
function createRecipeBuilder() {
    /// Called for every line of the recipe. Return true if parsing can
    /// continue, false on unrecoverable error.
    var parseLine = function (line) {
        line = line.trim();
        if (line === "") {
            return true;
        }

        log("Line from file: ", line);

        // Determine how far into the recipe we've already come.
        if (lastParsed === Section.FAIL) {
            log("Parse failed, aborting.");
            recipe = {}
            return false;
        }
        if (lastParsed === Section.INIT) {
            parseCategories(line);
        }
        else if (lastParsed === Section.CATEGORIES) {
            parseTitle(line);
        }
        else if (lastParsed === Section.TITLE) {
            parseServings(line);
        }
        else if (lastParsed === Section.SERVINGS) {
            parseIngredientTitle(line);
        } else if (lastParsed === Section.INGREDIENT && startsWithQuantity(line)) {
            // Line started with a number so must be an ingredient, right. Right? I hope so.
            parseIngredient(line);
        } else {
            // Classify the next line.
            // Is one of
            //   *<title>
            //   ~<temperature>
            //   -
            //   +<title>
            //   !<tips>
            const sectionID = line[0];
            switch (sectionID) {
                case SectionID.INGREDIENT_TITLE:
                    parseIngredientTitle(line);
                    break;
                case SectionID.OVEN_TEMP:
                    parseOvenTemp(line);
                    break;
                case SectionID.DESCRIPTION_MAIN:
                case SectionID.DESCRIPTION_GROUP:
                    parseDescriptionTitle(line);
                    break;
                case SectionID.TIPS_LONG:
                case SectionID.TIPS_SHORT:
                    parseTips(line);
                    break;
                default:
                    if (lastParsed == Section.DESCRIPTION) {
                        parseDescriptionText(line);
                    }
                    else {
                        log("Don't know how to parse line '", line, "'.");
                    }
                    break;
            }
        }

        return lastParsed != Section.FAIL;
    };

    /// Public getter function. Returns the recipe we just started parsin.
    /// Don't call this until the recipe has been completely parsed.
    ///
    /// \note This is the part the breaks if multiple recipes are being read in concurrently.
    var getRecipe = function () {
        return recipe;
    };


    const Section = {
        INIT: "init",
        CATEGORIES: "categories",
        TITLE: "title",
        SERVINGS: "servings",
        INGREDIENT: "ingredient",
        DESCRIPTION: "description",
        DESCRIPTION_TEXT: "description text"
    };


    const SectionID = {
        INGREDIENT_TITLE: "*",
        OVEN_TEMP: "~",
        DESCRIPTION_MAIN: "-",
        DESCRIPTION_GROUP: "+",
        TIPS_LONG: "Tips!",
        TIPS_SHORT: "!"
    }


    /// This is the object that is being filled in with every call to one of the
    /// parse.+ functions.
    var recipe = {};

    var currentIngredients = undefined;
    var currentDescription = undefined;

    /// Recipes follow a strict ordering of recipe elements. This tag keeps track
    /// of how far into the recipe we've come.
    var lastParsed = Section.INIT;


    function startsWithQuantity(line) {
        const words = line.split(" ");
        const startsWithNumber = !isNaN(Number(words[0].replace(",", ".")));
        return startsWithNumber;
    }


    /// Called when the next line of the recipe is expected to be the categories line.
    function parseCategories(line) {
        recipe.categories = [];
        var categoriesList = line.split(";");
        for (var i = 0; i < categoriesList.length - 1; i = i + 1) {
            var categoriesSublist = categoriesList[i].split(":");
            recipe.categories.push(categoriesSublist);
        }
        lastParsed = Section.CATEGORIES;
    }


    /// Called when the next line of the recipe is expected to be the title.
    function parseTitle(line) {
        if (!line) {
            log("Invalid recipe: Missing title.");
            lastParsed = Section.FAIL;
            return;
        }
        recipe.title = line;
        lastParsed = Section.TITLE;
    }


    /// Called when the next line of the recipe is expected to be the servings.
    function parseServings(line) {
        recipe.servings = {};
        const words = line.split(" ");
        if (words.length != 2)
        {
            log("Invalid recipe: Invalid servings, wrong number of words. '" + line + "'.");
            lastParsed = Section.FAIL;
            return;
        }
        recipe.servings.quantity = Number(words[0]);
        if (isNaN(recipe.servings.quantity)) {
            log("Invalid recipe: Invalid servings quantity. '" + words[0]);
        }
        recipe.servings.type = words[1];
        lastParsed = Section.SERVINGS;
        return true;
    }


    function parseIngredientTitle(line) {
        if (recipe.ingredients === undefined) {
            recipe.ingredients = [];
        }
        currentIngredients = {};
        recipe.ingredients.push(currentIngredients);
        currentIngredients.title = line.substr(1);
        currentIngredients.content = [];
        lastParsed = Section.INGREDIENT;
    }


    function extractName(line) {
        var words = line.split(" ");
        var name = words[2];
        for (var i = 3; i < words.length; ++i) {
            var word = words[i];
            if (word[0] !== "(") {
                name = name.concat(" ", word);
            } else {
                return name;
            }
        }

        return name;
    }


    function extractSpecifics(line) {
        var words = line.split(" ");
        var specifics = "";
        // Split into two steps, first to find ( and the second to build specifics.
        for (var i = 2; i < words.length; ++i) {
            var word = words[i];
            if (word[0] === "(") {
                for (var j = i; j < words.length; ++j) {
                    specifics = specifics.concat(" ", words[j]);
                }
                specifics = specifics.substring(2, specifics.length - 1);
            }
        }
        return specifics;
    }


    function parseIngredient(line) {
        line = line.replace(RegExp("\\s+", "g"), " ");
        var columns = line.split(RegExp("\\s"));
        var ingredient = {};
        ingredient.quantity = Number(line.split(" ")[0].replace(",", "."));
        if (isNaN(ingredient.quantity)) {
            log("Invalid recipe: Recipy quantity not a number. '" + line + ".");
            lastParsed = Section.FAIL;
            return;
        }
        ingredient.type = line.split(" ")[1];
        ingredient.name = extractName(line);
        ingredient.specifics = extractSpecifics(line);
        currentIngredients.content.push(ingredient);
    }


    function parseOvenTemp(line) {
        line = line.substr(1);
        if (line.length == 0) {
            // May not allow empty oven temp once we have recipe builder tool.
            return;
        }
        var digits = "";
        for (var i = 0; i < line.length; ++i) {
            if (line[i] >= '0' && line[i] <= '9') {
                digits = digits.concat(line[i]);
            } else {
                break;
            }
        }
        recipe.ovenTemp = Number(digits);
        if (isNaN(recipe.ovenTemp)) {
            log("Invalid recipe: Oven temperature is not a number. '" + line + "'");
            lastParsed = Section.FAIL;
        }
    }


    function parseDescriptionTitle(line) {
        if (recipe.description === undefined) {
            recipe.description = [];
        }

        /// \todo Create a new entry in the recipe.description array.
        ///       Save the created entry as currentDescription.
        currentDescription = {};
        currentDescription.title = undefined;
        currentDescription.content = [];
        var title = line.substr(1);
        currentDescription.title = title;
        recipe.description.push(currentDescription);
        lastParsed = Section.DESCRIPTION;
    }


    function parseDescriptionText(line) {
        currentDescription.content.push(line);
    }


    function parseTips(line) {
        const trimLength =
              line.startsWith(SectionID.TIPS_LONG) ?
              SectionID.TIPS_LONG.length :
              SectionID.TIPS_SHORT.length;
        recipe.tips = line.substr(trimLength).trim();
    }


    return { parseLine: parseLine, getRecipe: getRecipe };
}


exports.createRecipeBuilder = createRecipeBuilder;
exports.parseRecipeFromString = parseRecipeFromString;
