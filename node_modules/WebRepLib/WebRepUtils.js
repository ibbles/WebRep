
const filesystem = require('fs');
const iconv = require('iconv-lite');
var mongo = require('mongodb').MongoClient;
const util = require('util');


function log() {
    var toPrint = Array.prototype.slice.call(arguments);
    toPrint.unshift("WebRep:");
    console.log.apply(console, toPrint);
}


function guessEncoding(path) {
    var fileContents = filesystem.readFileSync(path);
    const indexOfUtf8Failure = iconv.decode(fileContents, 'utf8').indexOf('�');
    const isIsoMaybe = indexOfUtf8Failure >= 0;
    const encoding = isIsoMaybe ? 'iso-8859-15' : "utf8";
    return encoding;
}





// Global name of a function defined inside createRecipeBuilder that returns the
// last read recipe.
//
/// \note I don't think this is thread safe. If two recipes are being parsed at
///       the same time, then I guess the first user will see the second user's
///       recipe. That would be bad. 
// var recipeGetter;

// function getRecipe() {
    // return recipeGetter();
// }

/**
 * Constructor function that create a recipe builder object.
 * 
 * The recipe builder is a function that takes a single string argument and is
 * intended to be called for every line in a recipe text file. The recipe builder
 * captures a scope that contains helper function and intermediate results used
 * to construct the recipe object.
 */
function createRecipeBuilder() {
    /// This is the object that is being filled in with every call to one of the
    /// parse.+ functions.
    var recipe = {};

    var currentIngredients = undefined;
    var currentDescription = undefined;

    /// Recipes follow a strict ordering of recipe elements. This tag keeps track
    /// of how far into the recipe we've come.
    var lastParsed = ''; // One of 'categories', 'title', 'servings', etc.
    
    /// Called when the next line of the recipe is expected to be the categories line.
    function parseCategories(line) {
        recipe.categories = [];
        var categoriesList = line.split(";");
        for (var i = 0; i < categoriesList.length-1; i = i+1) {
            var categoriesSublist = categoriesList[i].split(":");
            recipe.categories.push(categoriesSublist);
        }
        lastParsed = 'categories';
        return true;
    }

    /// Called when the next line of the recipe is expected to be the title.
    function parseTitle(line) {
        recipe.title = line;
        lastParsed = 'title';
        return true;
    }



    /// Called when the next line of the recipe is expected to be the servings.
    function parseServings(line) {
        recipe.servings = {};
        recipe.servings.quantity = Number(line.split(" ")[0]);
        recipe.servings.type = line.split(" ")[1]; 
        lastParsed = 'servings';
        return true;
    }


    function parseIngredients(line) {
        if (recipe.ingredients === undefined) {
            recipe.ingredients = [];
        }
        currentIngredients = {};
        recipe.ingredients.push(currentIngredients);
        currentIngredients.title = line.substr(1);
        currentIngredients.content = [];
        lastParsed = "ingredients";
    }

    function extractName(line) {
        var words = line.split(" ");
        var name = words[2];
        for (var i = 3; i < words.length; ++i) {
            var word = words[i];
            if (word[0] !== "(") {
                name = name.concat(" ", word);
            } else {
                return name;
            }
        }

        return name;
    }

    function extractSpecifics(line) {
        var words = line.split(" ");
        var specifics = "";
        for (var i = 2; i < words.length; ++i) {
            var word = words[i];
            if (word[0] === "(") {
                for (var j = i; j < words.length; ++j) {
                    specifics = specifics.concat(" ", words[j]);
                }
                specifics = specifics.substring(2, specifics.length-1);
            }
        }
        return specifics;
    }

    function parseIngredient(line) {
        line = line.replace(RegExp("\\s+", "g"), " ");
        var columns = line.split(RegExp("\\s"));
        var ingredient = {};
        ingredient.quantity = Number(line.split(" ")[0].replace(",", "."));
        ingredient.type = line.split(" ")[1];
        ingredient.name = extractName(line);
        ingredient.specifics = extractSpecifics(line);
        currentIngredients.content.push(ingredient);
    }


    function parseOvenTemp(line) {
        line = line.substr(1);
        var digits = "";
        for (var i = 0; i < line.length; ++i) {
            if (line[i] >= '0' && line[i] <= '9') {
                digits = digits.concat(line[i]);
            } else {
                break;
            }
        }

        recipe.ovenTemp = Number(digits);
    }
    
    function parseDescription(line)
    {
        if (recipe.description === undefined) {
            recipe.description = [];
        }

        /// \todo Create a new entry in the recipe.description array.
        ///       Save the created entry as currentDescription.
        currentDescription = {};
        currentDescription.title = undefined;
        currentDescription.content = [];
        var title = line.substr(1);
        if (title === "") {
            currentDescription.title = "Gör så här";
        } else {
            currentDescription.title = title;
        }
        recipe.description.push(currentDescription);
        lastParsed = 'description';
    }

    function parseDescriptionText(line) {
        currentDescription.content.push(line);
    }


    function parseTips(line) {
        if (line.startsWith('Tips!')) {
            recipe.tips = line.substr(5);
        }
        else {
            recipe.tipes = line.substr(1);
        }
    }


    /// Public getter function. Returns the recipe we just started parsin.
    /// Don't call this until the recipe has been completely parsed.
    ///
    /// \note This is the part the breaks if multiple recipes are being read in concurrently.
    var recipeGetter = function() {
        return recipe;
    };


    /// Called for every line of the recipe.
    var parseLine = function(line) {
        line = line.trim();
        if (line === "") {
            return;
        }

        // Determine how far into the recipe we've already come.
        if (lastParsed === '') {
            parseCategories(line);
        }
        else if (lastParsed === 'categories') {
            parseTitle(line);
        }
        else if (lastParsed === 'title') {
            parseServings(line);
        }
        else {
            // Classify the next line.
            // Is one of
            //   *<title>
            //   ~<temperature>
            //   -
            //   +<title>
            //   !<tips>
            if (line[0] === '*') {
                parseIngredients(line);
            } else if (lastParsed === "ingredients" && !isNaN(Number(line.split(" ")[0].replace(",", ".")))) {
                // Lines started with a number so must be an ingredient, right. Right? I hope so.
                parseIngredient(line);
            } else if (line[0] === '~') {
                parseOvenTemp(line);
            } else if (line[0] === '-' || line[0] === '+') {
                parseDescription(line);
            } else if (line[0] === '!' || line.startsWith('Tips!')) {
                parseTips(line);
            } else if (lastParsed === "description") {
                parseDescriptionText(line);
            } else {
                console.log("Don't know how to parse line '", line, "'.");
            }
        }
    };

    return {parseLine: parseLine, recipeGetter: recipeGetter};
}




function parseRecipeFromString(recipeText) {
    var recipeBuilder = createRecipeBuilder();
    const lines = recipeText.split('\n');
    lines.forEach(function(line) {
        line = line.trim();
        recipeBuilder.parseLine(line);
    });

    const recipe = recipeBuilder.recipeGetter();
    return recipe;
}


function parseRecipeFromFile() {

}



/*
Step:
  mongo + connect -> db + collection
  db + collection -> collection
  collection + find -> existingRecipes
  collection + existingRecipes + (insert | reject) -> (log | log)
*/

function saveRecipeToDatabase(recipe, allowOverwrite) {
    console.log('Estrablishing database connection.');
    var conn = {
        db: undefined,
        collection: undefined
    };

    return mongo.connect('mongodb://127.0.0.1:27017/recipes')
            .then(function(db) {
                console.log('Connection to database established. Creating collection handle.');
                conn.db = db;
                return db.collection("recipes")
            })
            .then(function(collection) {
                console.log('Collection handle created. Extracting recipe list.');
                conn.collection = collection;
                return collection.find({title: recipe.title}).toArray();
            })
            .then(function (existingRecipes) {
                console.log('Recipe list extracted. checking size.');
                return new Promise(function(resolve, reject) {
                    if (existingRecipes.length == 0) {
                        console.log('Recipe list verified. Inserting.');
                        resolve(conn.collection.insert(recipe)
                                .then(function() {
                                    console.log('Recipe inserted. saveRecipeToDatabase finished.');
                                    conn.db.close();
                                    return 'Recipe "' + recipe.title + '" inserted with id "' + recipe._id + '.';
                                })
                                .catch(function(error) {
                                    console.log('Recipe insertion failed. Sending formatted reject.');
                                    conn.db.close();
                                    // Is this Promise necessary, or can I just return the error message?
                                    // No, a return from a catch is seen as a resolve.
                                    return new Promise(function(resolve, reject) {
                                        reject('Failed to insert recipe "' + recipe.title + '": ' + error + ".");
                                    });
                                }));
                    }
                    else if (existingRecipes.length == 1 && allowOverwrite) {
                        query = {
                            _id: existingRecipes[0]._id
                        };
                        options = {
                            upsert: false,
                            multi: false,
                            // writeConcern: {},
                            // collation: {}
                        }
                        resolve(conn.collection.update(query, recipe, options)
                                .then(function() {
                                    console.log("Recipe updated.");
                                    conn.db.close();
                                    return "Recipe '" + recipe.title + '"updated.';
                                })
                                .catch(function(error) {
                                    console.log("Recipe update failed. Sendinf formatted reject.");
                                    conn.db.close();
                                    return new Promise(function(resolve, reject) {
                                        reject("Failed to insert recipe '" + recipe.title + "': " + error + ".");
                                    });
                                }));
                    }
                    else {
                        console.log('Recipe list error. Rejecting.');
                        console.log('Got the following ' + existingRecipes.length + ' recipes:');
                        console.log(util.inspect(existingRecipes, { showHidden: false, depth: null }));
                        conn.db.close();
                        reject('Already have a recipe named "' + recipe.title + '". Nothing inserted.');
                    }
                });
            });
}

exports.log = log;
exports.guessEncoding = guessEncoding;
exports.saveRecipeToDatabase = saveRecipeToDatabase;
exports.createRecipeBuilder = createRecipeBuilder;
exports.parseRecipeFromString = parseRecipeFromString;

