
const filesystem = require('fs');
const iconv = require('iconv-lite');
var mongo = require('mongodb').MongoClient;


function log() {
    var toPrint = Array.prototype.slice.call(arguments);
    toPrint.unshift("WebRep:");
    console.log.apply(console, toPrint);
}


function guessEncoding(path) {
    var fileContents = filesystem.readFileSync(path);
    const indexOfUtf8Failure = iconv.decode(fileContents, 'utf8').indexOf('�');
    const isIsoMaybe = indexOfUtf8Failure >= 0;
    const encoding = isIsoMaybe ? 'iso-8859-15' : "utf8";
    return encoding;
}





// Global name of a function defined inside createRecipeBuilder that returns the
// last read recipe.
//
/// \note I don't think this is thread safe. If two recipes are being parsed at
///       the same time, then I guess the first user will see the second user's
///       recipe. That would be bad. 
// var recipeGetter;

// function getRecipe() {
    // return recipeGetter();
// }

/**
 * Constructor function that create a recipe builder object.
 * 
 * The recipe builder is a function that takes a single string argument and is
 * intended to be called for every line in a recipe text file. The recipe builder
 * captures a scope that contains helper function and intermediate results used
 * to construct the recipe object.
 */
function createRecipeBuilder() {
    /// This is the object that is being filled in with every call to one of the
    /// parse.+ functions.
    var recipe = {};

    var currentIngredients = undefined;
    var currentDescription = undefined;

    /// Recipes follow a strict ordering of recipe elements. This tag keeps track
    /// of how far into the recipe we've come.
    var lastParsed = ''; // One of 'categories', 'title', 'servings', etc.
    
    /// Called when the next line of the recipe is expected to be the categories line.
    function parseCategories(line) {
        recipe.categories = [];
        var categoriesList = line.split(";");
        for (var i = 0; i < categoriesList.length-1; i = i+1) {
            var categoriesSublist = categoriesList[i].split(":");
            recipe.categories.push(categoriesSublist);
        }
        lastParsed = 'categories';
        return true;
    }

    /// Called when the next line of the recipe is expected to be the title.
    function parseTitle(line) {
        recipe.title = line;
        lastParsed = 'title';
        return true;
    }



    /// Called when the next line of the recipe is expected to be the servings.
    function parseServings(line) {
        recipe.servings = {};
        recipe.servings.quantity = Number(line.split(" ")[0]);
        recipe.servings.type = line.split(" ")[1]; 
        lastParsed = 'servings';
        return true;
    }


    function parseIngredients(line) {
        if (recipe.ingredients === undefined) {
            recipe.ingredients = [];
        }
        currentIngredients = {};
        recipe.ingredients.push(currentIngredients);
        currentIngredients.title = line.substr(1);
        currentIngredients.content = [];
        lastParsed = "ingredients";
    }

    function extractName(line) {
        var words = line.split(" ");
        var name = words[2];
        for (var i = 3; i < words.length; ++i) {
            var word = words[i];
            if (word[0] !== "(") {
                name = name.concat(" ", word);
            } else {
                return name;
            }
        }

        return name;
    }

    function extractSpecifics(line) {
        var words = line.split(" ");
        var specifics = "";
        for (var i = 2; i < words.length; ++i) {
            var word = words[i];
            if (word[0] === "(") {
                for (var j = i; j < words.length; ++j) {
                    specifics = specifics.concat(" ", words[j]);
                }
                specifics = specifics.substring(2, specifics.length-1);
            }
        }
        return specifics;
    }

    function parseIngredient(line) {
        line = line.replace(RegExp("\\s+", "g"), " ");
        var columns = line.split(RegExp("\\s"));
        var ingredient = {};
        ingredient.quantity = Number(line.split(" ")[0].replace(",", "."));
        ingredient.type = line.split(" ")[1];
        ingredient.name = extractName(line);
        ingredient.specifics = extractSpecifics(line);
        currentIngredients.content.push(ingredient);
    }


    function parseOvenTemp(line) {
        line = line.substr(1);
        var digits = "";
        for (var i = 0; i < line.length; ++i) {
            if (line[i] >= '0' && line[i] <= '9') {
                digits = digits.concat(line[i]);
            } else {
                break;
            }
        }

        recipe.ovenTemp = Number(digits);
    }
    
    function parseDescription(line)
    {
        if (recipe.description === undefined) {
            recipe.description = [];
        }

        /// \todo Create a new entry in the recipe.description array.
        ///       Save the created entry as currentDescription.
        currentDescription = {};
        currentDescription.title = undefined;
        currentDescription.content = [];
        var title = line.substr(1);
        if (title === "") {
            currentDescription.title = "Gör så här";
        } else {
            currentDescription.title = title;
        }
        recipe.description.push(currentDescription);
        lastParsed = 'description';
    }

    function parseDescriptionText(line) {
        currentDescription.content.push(line);
    }


    function parseTips(line) {
        if (line.startsWith('Tips!')) {
            recipe.tips = line.substr(5);
        }
        else {
            recipe.tipes = line.substr(1);
        }
    }


    /// Public getter function. Returns the recipe we just started parsin.
    /// Don't call this until the recipe has been completely parsed.
    ///
    /// \note This is the part the breaks if multiple recipes are being read in concurrently.
    var recipeGetter = function() {
        return recipe;
    };


    /// Called for every line of the recipe.
    var parseLine = function(line) {
        line = line.trim();
        if (line === "") {
            return;
        }

        // Determine how far into the recipe we've already come.
        if (lastParsed === '') {
            parseCategories(line);
        }
        else if (lastParsed === 'categories') {
            parseTitle(line);
        }
        else if (lastParsed === 'title') {
            parseServings(line);
        }
        else {
            // Classify the next line.
            // Is one of
            //   *<title>
            //   ~<temperature>
            //   -
            //   +<title>
            //   !<tips>
            if (line[0] === '*') {
                parseIngredients(line);
            } else if (lastParsed === "ingredients" && !isNaN(Number(line.split(" ")[0].replace(",", ".")))) {
                // Lines started with a number so must be an ingredient, right. Right? I hope so.
                parseIngredient(line);
            } else if (line[0] === '~') {
                parseOvenTemp(line);
            } else if (line[0] === '-' || line[0] === '+') {
                parseDescription(line);
            } else if (line[0] === '!' || line.startsWith('Tips!')) {
                parseTips(line);
            } else if (lastParsed === "description") {
                parseDescriptionText(line);
            } else {
                console.log("Don't know how to parse line '", line, "'.");
            }
        }
    };

    return {parseLine: parseLine, recipeGetter: recipeGetter};
}







function saveRecipeToDatabase(recipe) {
    mongo.connect('mongodb://127.0.0.1:27017/recipes', function (error, db) {
        if (error) {
            console.log("Could not connect to database.");
            throw error;
        }

        console.log("Connection to database established.");

        var collection = db.collection("recipes");
        collection.insert(recipe, function (error, docs) {
            if (error) {
                console.log("Could not insert recipe into database: " + error);
                db.close();
            }
            console.log("Inserted", recipe.title);
            console.log("ID:", recipe._id);
            db.close();
        });
    });
}

exports.log = log;
exports.guessEncoding = guessEncoding;
exports.saveRecipeToDatabase = saveRecipeToDatabase;
exports.createRecipeBuilder = createRecipeBuilder;
// exports.getRecipe = getRecipe
